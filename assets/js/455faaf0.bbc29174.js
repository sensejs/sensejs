"use strict";(self.webpackChunk_sensejs_sensejs_doc=self.webpackChunk_sensejs_sensejs_doc||[]).push([[708],{6658:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var t=i(5250),s=i(7766);const o={id:"injection-scope",sidebar_position:2},c="Injection Scope",r={id:"injection/injection-scope",title:"Injection Scope",description:"All injectables are defined within a scope. Just like all other dependency injection frameworks, SenseJS provides",source:"@site/docs/injection/scopes.md",sourceDirName:"injection",slug:"/injection/injection-scope",permalink:"/docs/injection/injection-scope",draft:!1,unlisted:!1,editUrl:"https://github.com/sensejs/sensejs/edit/master/website/docs/injection/scopes.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"injection-scope",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Provide Injectables",permalink:"/docs/injection/defining-injectables"},next:{title:"Method Invoker",permalink:"/docs/injection/method-invoking"}},a={},l=[];function d(e){const n={code:"code",h1:"h1",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"injection-scope",children:"Injection Scope"}),"\n",(0,t.jsx)(n.p,{children:"All injectables are defined within a scope. Just like all other dependency injection frameworks, SenseJS provides\nthe following injection scopes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SINGLETON"}),": Injectables within this scope will be instantiated only once during the application lifetime."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"SESSION"}),": Injectables within this scope will be instantiated once in each dependency injection session, which is\nusually the lifecycle of a request. It is also the default scope of a component if unspecified"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"TRANSIENT"}),": Injectables within this scope are instantiated each time for each param it bound to; if more than one\nparam bound to such an injectable, multiple instances of it will be created."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To specify the scope of a component, you can use the ",(0,t.jsx)(n.code,{children:"@Scope()"})," decorator, for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"\n@Component()\n@Scope(Scope.SINGLETON)\nclass SingletonComponent {\n\n  myMethod() {\n    //...\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"For injectables provided by a factory, the scope is specified by their provider:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const MyModule = createModule({\n  factories: [{\n    provide: MyInjectable,\n    factory: MyFactory,\n    scope: Scope.SINGLETON\n  }]\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["While constant injectables are always ",(0,t.jsx)(n.code,{children:"SINGLETON"})," scoped."]})]})}function p(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},7766:(e,n,i)=>{i.d(n,{Z:()=>r,a:()=>c});var t=i(79);const s={},o=t.createContext(s);function c(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);