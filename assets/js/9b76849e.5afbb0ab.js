"use strict";(self.webpackChunksensejs_doc=self.webpackChunksensejs_doc||[]).push([[681],{5176:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return p},default:function(){return c}});var o=t(1725),a=t(8836),i=(t(9231),t(4852)),l=["components"],r={id:"module",sidebar_position:4},s="Module",d={unversionedId:"overview/module",id:"overview/module",isDocsHomePage:!1,title:"Module",description:"In this article, we'll discuss more details about SenseJS modules.",source:"@site/docs/overview/module.md",sourceDirName:"overview",slug:"/overview/module",permalink:"/docs/overview/module",editUrl:"https://github.com/sensejs/sensejs/edit/master/website/docs/overview/module.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"module",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Injection",permalink:"/docs/overview/injection"}},p=[{value:"Creating a module",id:"creating-a-module",children:[],level:2},{value:"Lifecycle hooks",id:"lifecycle-hooks",children:[],level:2},{value:"Inter-Module dependencies",id:"inter-module-dependencies",children:[],level:2},{value:"Entry point modules",id:"entry-point-modules",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],u={toc:p};function c(e){var n=e.components,t=(0,a.Z)(e,l);return(0,i.kt)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"module"},"Module"),(0,i.kt)("p",null,"In this article, we'll discuss more details about SenseJS modules."),(0,i.kt)("p",null,"In the previous article, you've learned to export injectables through modules. You might note that to start an HTTP\nserver, ",(0,i.kt)("inlineCode",{parentName:"p"},"createHttpModule")," is called, which manages HTTP traffics for you. You might also note that the application\nentry point is also a module."),(0,i.kt)("p",null,"The concept of the module takes an important roles in SenseJS. It's designed to do the following job for your\napplication:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Provide entry points for your application.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Export injectables for other modules and components to use.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Initialize and de-initialize components and I/O resources, such as creating database connections and establishing\nHTTP listeners."))),(0,i.kt)("h2",{id:"creating-a-module"},"Creating a module"),(0,i.kt)("p",null,"You can create a module by decorating a class with ",(0,i.kt)("inlineCode",{parentName:"p"},"@ModuleClass"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@ModuleClass({\n    requires: [],   // Other modules that required by this module\n    components: [], // Component injectable provided by this module\n    factories: [],  // Dynamic injectable provided by this module\n    constants: [],  // Constant injectables provided by this module\n})\nclass MyModule {\n\n    constructor(@Inject(Loggable) loggable: Loggable) {\n        loggable.log('Hello from MyModule');\n    }\n\n    @OnModuleCreated()\n    onModuleCreated() {} // perform initialization here\n\n    @OnModuleCreated()\n    onModuleDestroy() {} // perform de-initialization here\n}\n")),(0,i.kt)("p",null,"A module can have a constructor, and its parameters are automatically injected by the framework."),(0,i.kt)("p",null,"In case that neither constructor nor lifecycle hooks is needed, you can also create a module in a simpler way:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const MyModule = createModule({\n    requires: [],\n    components: [],\n    factories: [],\n    constants: [],\n});\n")),(0,i.kt)("h2",{id:"lifecycle-hooks"},"Lifecycle hooks"),(0,i.kt)("p",null,"SenseJS defined four lifecycle hooks for modules. Just like module constructor, parameters of these lifecycle hooks\nare automatically injected by the framework."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"OnModuleCreated"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"OnModuleStop"),": called when the module is created/destroyed, respectively."),(0,i.kt)("p",{parentName:"li"},"  When your components need to be initialized and de-initialized, it shall be done in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"@OnModuleCreate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@OnModuleDestroy")," hooks of a module."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"\n@Component({scope: ComponentScope.SINGLETON})\nclass DatabaseConnection {\n    async connect() { }\n    async disconnect() { }\n    async query() { }\n}\n\n@ModuleClass({components: [DatabaseConnection]})\nclass DatabaseModule {\n\n    @OnModuleCreated()\n    async onCreated(@Inject(DatabaseConnection) conn) {\n        await conn.connect();\n    }\n\n    @OnModuleDestroy()\n    async onDestroyed(@Inject(DatabaseConnection) conn) {\n        await conn.disconnect();\n    }\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"OnModuleStart"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"OnModuleStop"),": only when you start your app via ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationRunner.start"),"(see ",(0,i.kt)("a",{parentName:"p",href:"#entry-point-modules"},"EntryPointModules"),")"),(0,i.kt)("p",{parentName:"li"},"  When a module is designed to handle requests, it needs",(0,i.kt)("inlineCode",{parentName:"p"},"@OnModuleStart")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@OnModuleStop")," hooks."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@ModuleClass()\nclass TcpEchoServerModule {\n    tcpServer?: net.Server;\n\n    @OnModuleStart()\n    async onCreated() {\n        this.tcpServer = net.createServer((conn)=> conn.pipe(conn)).listen(3000);\n    }\n\n    @OnModuleStop()\n    async onDestroyed() {\n        if (this.tcpServer) {\n            this.tcpServer.close();\n        }\n    }\n}\n")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("inlineCode",{parentName:"p"},"OnModuleCreate")," hooks are ensured be invoked after all ",(0,i.kt)("inlineCode",{parentName:"p"},"OnModuleCreated")," hooks finished, while ",(0,i.kt)("inlineCode",{parentName:"p"},"OnModuleDestroy"),"\nhooks are ensured to be invoked before any ",(0,i.kt)("inlineCode",{parentName:"p"},"OnModuleDestroy")," hooks. This is how SenseJS gracefully startup and\nshutdown your app."))),(0,i.kt)("h2",{id:"inter-module-dependencies"},"Inter-Module dependencies"),(0,i.kt)("p",null,"To control the initialization and de-initialization order, you need to specify which one depends on the other ones."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"\n@Controller()\nclass MyController {\n\n    @GET('/')\n    async query(@Inject(DatabaseConnection) conn) {\n        return conn.query();\n    }\n}\n\n\nconst BusinessLogicModule = createModule({\n    requires: [DatabaseModule],\n    components: [MyController],\n});\n")),(0,i.kt)("p",null,"Note that once a module is initialized, anything provided by it will be injectable to others, even components from the\nother modules that do not list it as a dependency. In other words, the inter-module dependency graph only affects the\norder of initialization and de-initialization but does not restrict you from injecting anything from any other module.\nHowever, it is still a good practice to carefully consider the relationship between modules."),(0,i.kt)("h2",{id:"entry-point-modules"},"Entry point modules"),(0,i.kt)("p",null,"There ought to be an entry point for an app. In SenseJS, your app can be started through:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@ModuleClass({ requires: [OtherModules] })\nclass MyApp {\n    main() {\n    }\n}\n\nApplicationRunner.instance.run(MyApp, 'main');\n")),(0,i.kt)("p",null,"And your app will exit when it returns from ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),"."),(0,i.kt)("p",null,"Some app may not have any explicit entry function, but establish a listener in ",(0,i.kt)("inlineCode",{parentName:"p"},"OnModuleStart")," hooks and then\nwait for requests. In this case, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationRunner.instance.start")," to start your app."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@ModuleClass({ requires: [OtherModules] })\nclass MyApp {\n    @OnModuleStart()\n    onModuleStart() {\n        // start listening for requests\n    }\n    @OnModuleStop()\n    onModuleStop() {\n        // stop listening for requests\n    }\n}\nApplicationRunner.instance.start(MyApp);\n")),(0,i.kt)("p",null,"Such app will not exit until ",(0,i.kt)("inlineCode",{parentName:"p"},"ProcessManager.exit()")," is called or any exit signals are received. SenseJS also ensures\nall ",(0,i.kt)("inlineCode",{parentName:"p"},"@OnModuleStop")," hooks are invoked before the app exits."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"From a global perspective, a typical SenseJS application is composed of modules. Some modules are organizing\ninjectables, while some modules are also managing I/O, and an entry module that depends on all the others.\nBased on the dependency graph of all the modules, SenseJS can gracefully start up and shut down your application."))}c.isMDXComponent=!0}}]);